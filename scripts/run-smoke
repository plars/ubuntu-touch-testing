#!/usr/bin/python

import argparse
import logging
import os
import shutil
import subprocess

import yaml

from phabletutils.environment import detect_device

import dashboard
import statsd

log = logging.getLogger()
script_dir = os.path.dirname(__file__)
res_dir = os.path.join(os.getcwd(), 'clientlogs')

dashboard_api = dashboard.API()


class SerialAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        log.info('android serial: %s', values[0])
        os.environ['ANDROID_SERIAL'] = values[0]


class DebugAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        log.setLevel(level=logging.DEBUG)
        log.debug('debug logging enabled')


def _serial_required():
    required = 'ANDROID_SERIAL' not in os.environ
    if required:
        try:
            out = subprocess.check_output(['adb', 'devices'])
            required = (len(out.decode().split('\n')) != 4)
        except subprocess.CalledProcessError as e:
            logging.debug('error getting adb devices: %s', e)
    return required


def _get_parser():
    parser = argparse.ArgumentParser(
        description='Run the complete test-execution-service suite.')

    parser.add_argument('-s', '--serial', action=SerialAction, nargs=1,
                        required=_serial_required(),
                        help='Android serial if more than one device present')
    parser.add_argument('--debug', action=DebugAction, nargs=0,
                        help='''Enable debug logging.''')

    parser.add_argument('--install-url',
                        help='''Flash with image from previous jenkins job.
                        This option will check if the device already has image
                        noted from this URL and will skip provisioning. The URL
                        should be the path the job like:
                        http://q-jenkins:8080/job/<your job>/<build number>''')
    parser.add_argument('-p', '--package', action='append',
                        help='Additional packages to install on target.')
    parser.add_argument('-P', '--ppa', action='append',
                        help='Additional PPA to configure on target.')
    parser.add_argument('-a', '--app', action='append',
                        help='Autopilot tests tor run.')
    parser.add_argument('-t', '--test', action='append',
                        help='UTAH tests tor run.')
    parser.add_argument('--image-opt',
                        help='Options to pass to phablet-flash')
    parser.add_argument('--image-type', default='touch',
                        help='''Image type being tested. This can be changed
                        to 'touch_sf4p' so that SurfaceFlinger will be used
                        instead of Mir. default=%(default)s''')
    return parser


def _arg_from_env(args, attr, envkey, array):
    val = os.environ.get(envkey, False)
    if val:
        if array:
            setattr(args, attr, val.split())
        else:
            setattr(args, attr, val)
        del os.environ[envkey]


def _merge_env(args):
    '''When run in Jenkins everything comes as environment variables.

    Its makes a much simpler job this way. While command line args are
    much easier for a user.
    '''
    _arg_from_env(args, 'app', 'APPS', True)
    _arg_from_env(args, 'test', 'TESTS', True)
    _arg_from_env(args, 'package', 'PACKAGES', True)
    _arg_from_env(args, 'ppa', 'PPAS', True)
    _arg_from_env(args, 'image_opt', 'IMAGE_OPT', False)
    _arg_from_env(args, 'image_type', 'IMAGE_TYPE', False)
    _arg_from_env(args, 'install_url', 'INSTALL_URL', False)


def _assert_args(args):
    if args.install_url:
        # this means you shouldn't specify packages, ppas, or image options
        if args.package or args.ppa or args.image_opt:
            msg = 'ERROR: --install-url can\'t be used with ' \
                  '--package, -ppa, or --image_opt'
            print(msg)
            return False

    # don't bother the install_url check, a user might be copy/pasting and
    # doesn't hurt. Its just good to not encourage it.
    _merge_env(args)

    script = os.path.join(script_dir, '../jenkins/testconfig.py')
    if args.package and args.package[0] == 'ALL':
        logging.info('Discovering all required dependencies')
        out = subprocess.check_output(
            [script, 'packages', '-i', args.image_type])
        args.package = [x for x in out.decode().split()]

    if args.app and args.app[0] == 'ALL':
        logging.info('Discovering all autopilot tests')
        out = subprocess.check_output(
            [script, 'apps', '-i', args.image_type])
        args.app = [x for x in out.decode().split()]

    if args.test and args.test[0].startswith('ALL'):
        logging.info('Discovering all UTAH tests')
        argv = [script, 'utah', '-i', args.image_type]
        if args.test[0] == 'ALL_INCLUDING_AUTOPILOT':
            argv.append('-a')
        out = subprocess.check_output(argv)
        args.test = [x for x in out.decode().split()]

    logging.debug('ARGS: %r', args)

    statsd.gauge_it('PACKAGES', args.package)
    statsd.gauge_it('APPS', args.app)
    statsd.gauge_it('TESTS', args.test)

    return True


def _run(args, ignore_error=False):
    try:
        logging.info('Running: %s', ' '.join(args))
        subprocess.check_call(args)
    except subprocess.CalledProcessError:
        if ignore_error:
            logging.error('failed to run %r, continuing', args)
        else:
            exit(1)


def _image_info():
    info = subprocess.check_output(['adb', 'shell', 'system-image-cli', '-i'])
    v_ver = u_ver = d_ver = channel = None
    for line in info.split('\n'):
        if not line.strip():
            continue
        key, val = line.split(':', 1)
        if key == 'version version':
            v_ver = val.strip()
        elif key == 'version ubuntu':
            u_ver = val.strip()
        elif key == 'version device':
            d_ver = val.strip()
        elif key == 'channel':
            channel = val.strip()
    ver = '%s:%s:%s' % (v_ver, u_ver, d_ver)
    return ver, channel


def _assert_image(args):
    log.info('checking if device has proper image ...')
    os.environ['INSTALL_URL'] = args.install_url
    _run([os.path.join(script_dir, 'assert-image')])


def _provision(args):
    log.info('provisioning device ...')
    if args.image_opt:
        log.debug('overriding IMAGE_OPT with: %s', args.image_opt)
        os.environ['IMAGE_OPT'] = args.image_opt

    cargs = [os.path.join(script_dir, 'provision.sh'), '-i', args.image_type]

    if args.package:
        for p in args.package:
            cargs.extend(['-p', p])
    if args.ppa:
        for p in args.ppa:
            cargs.extend(['-P', p])
    if args.test and not args.ppa and not args.package:
        # UTAH tests require a writeable system the -p and -P args
        # implicitly create a writable system. so we have to ensure here:
        cargs.append('-w')

    with statsd.time_it('provision'):
        _run(cargs)


def _test_autopilot(args, build, image):
    if args.app:
        os.environ['DASHBOARD_BUILD'] = build
        os.environ['DASHBOARD_IMAGE'] = image
        cargs = [os.path.join(script_dir, 'run-autopilot-tests.sh')]
        for app in args.app:
            cargs.extend(['-a', app])
        with statsd.time_it('APPS'):
            _run(cargs)


def _sync_results(build, image, test, fname):
    with open(fname) as f:
        d = yaml.safe_load(f)
        dashboard_api.result_syncing(
            image, build, test, d['passes'], d['failures'], d['errors'])


def _test_utah(args, build, image):
    if args.test:
        cargs = [os.path.join(script_dir, 'jenkins.sh')]
        with statsd.time_it('TESTS'):
            for test in args.test:
                os.environ['RESDIR'] = os.path.join(res_dir, test)
                dashboard_api.result_running(image, build, test)
                _run(cargs + ['-a', test], ignore_error=True)
                fname = os.path.join(res_dir, test, 'utah.yaml')
                _sync_results(build, image, test, fname)


def _image_add(args):
    build_number, channel = _image_info()
    release = channel.split('-')[0]
    return dashboard_api.image_add(
        build_number, release, args.image_type, detect_device(None), 'ubuntu')


def main(args):
    with statsd.time_it('main'):
        if os.path.exists(res_dir):
            logging.info('deleting old result directory: %s', res_dir)
            shutil.rmtree(res_dir)
        os.mkdir(res_dir)

        job_name = os.environ.get('JOB_NAME', '')
        job_number = os.environ.get('BUILD_NUMBER', '')
        build = dashboard_api.build_add(job_name, job_number)

        if args.install_url:
            _assert_image(args)
        else:
            _provision(args)

        # TODO - this should be incororated into provision and assert_image
        # so that the status is updated *before* flashing rather than after
        image = _image_add(args)

        if args.test:
            for x in args.test:
                dashboard_api.result_queue(image, build, x)
        if args.app:
            for x in args.app:
                dashboard_api.result_queue(image, build, x)

        _test_autopilot(args, build, image)

        _test_utah(args, build, image)

    return 0


if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    log.name = 'run-smoke'
    dashboard.log = logging.getLogger('dashboard')

    args = _get_parser().parse_args()
    if not _assert_args(args):
        exit(1)

    exit(main(args))
